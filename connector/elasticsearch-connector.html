<html>
<meta http-equiv="Cache-Control" content="no-store" />
<head>
<title>Stock Quote Connector</title>
  <link rel="stylesheet" href="/bootstrap/css/bootstrap.min.css">
  <script src="/jquery/jquery.min.js" type="text/javascript"></script>
  <script src="/bootstrap/js/bootstrap.min.js" type="text/javascript"></script>
  <script src="/lodash/lodash.js" type="text/javascript"></script>
  <script src="/resources/tableau.js" type="text/javascript"></script>
<script type="text/javascript">
 (function() {

  var elasticsearchTableauDataTypeMap = {
    string: 'string',
    float: 'float',
    long: 'int',
    int: 'int',
    date: 'date',
    boolean: 'bool'
  },
    elasticsearchFields = [];
  //
  // Helper functions
  //
  
  var getElasticsearchTypeMapping = function(url, index, type){
        
    elasticsearchFields.push({ name: '_id', dataType: 'string' });
    elasticsearchFields.push({ name: '_sequence', dataType: 'int' });
    
    $.ajax(url + '/' + index + '/' + type + '/_mapping', {
      dataType: 'json',
      success: function(data){
                
        _.forIn(data[index].mappings[type].properties, function(val, key){
          // TODO: Need to support all data types
          // TODO: Need to support nested objects and arrays in some way
          if(_.isUndefined(elasticsearchTableauDataTypeMap[val.type])){
            return;
          }
          
          var field = {
            name: key,
            dataType: elasticsearchTableauDataTypeMap[val.type] 
          };
          elasticsearchFields.push(field);    
        });
        
        tableau.log('Header columns: ', JSON.stringify(elasticsearchFields));
        
        tableau.submit();
      },
      error: function(xhr, ajaxOptions, err){
          tableau.log("connection error: " + xhr.responseText + "\n" + thrownError);
          tableau.abortWithError("error connecting to the Elasticsearch cluster for mapping");
      }
    }); 
  }

  //
  // Connector definition
  // 

  var myConnector = tableau.makeConnector();

  myConnector.getColumnHeaders = function() {
    tableau.headersCallback(_.pluck(elasticsearchFields, 'name'), _.pluck(elasticsearchFields, 'dataType'));
  };
   
  myConnector.getTableData = function(lastRecordToken) {
    
    var lastTo = parseInt(lastRecordToken) || 0;
    var connectionData = JSON.parse(tableau.connectionData);
       
    // TODO: Add support to define a custom query to extract data with
    var requestData = {
      query: { match_all: {} },
      from: lastTo + 1,
      size: connectionData.batchSize
    };
    
	var connectionUrl = connectionData.elasticsearchUrl + '/' + connectionData.elasticsearchIndex + '/' + 
           connectionData.elasticsearchType + '/_search';
	
    var xhr = $.ajax({
        url: connectionUrl,
        method: 'POST',
        processData: false,
        data: JSON.stringify(requestData),
        dataType: 'json',
        success: function (data) {

			  if (data.hits.hits) {
              var hits = data.hits.hits;
              var ii;
              var toRet = [];
              // mash the data into an array of objects
              for (ii = 0; ii < hits.length; ++ii) {
                  // Each entry can be a list of values in the same order as the columns
                  //var entry = [quotes[ii].Symbol, quotes[ii].Date, quotes[ii].Close];
                  // or an object where the column names are the keys of the map
                  
                            var item = hits[ii]._source;
          item._id = hits[ii]._id;
          item._sequence = ii;
          
                  //var entry = {'Ticker': quotes[ii]._source.PROPERTY_NAME, 
                  //             'Day': quotes[ii]._source.MODIFIED_ON, 
                  //             'Close': quotes[ii]._source.TOTAL_AVAIL_SF};
                  toRet.push(item);
              }
              // Call back to tableau with the table data and the new record number (this is stored as a string)
              tableau.dataCallback(toRet, toRet.length.toString(), false);
            } else {
              tableau.abortWithError("No results found for ticker symbol: " + ticker);
            }
        },
        error: function (xhr, ajaxOptions, thrownError) {
          // add something to the log and return an empty set if there was problem with the connection
          tableau.log("connection error: " + xhr.responseText + "\n" + thrownError);
          tableau.abortWithError("error connecting to the yahoo stock data source");
        }
    });
  };

  myConnector.setTicker = function(tickerSymbol) {
    tableau.connectionData = tickerSymbol; // set the ticker symbol as the connection data so we can get to it when we fetch the data
    tableau.connectionName = 'Stock quote: ' + tickerSymbol; // name the data source. This will be the data source name in Tableau
  };

  tableau.registerConnector(myConnector);

  //
  // Setup connector UI
  //
 
  $(document).ready(function() {
    $("#submitButton").click(function(e) { // This event fires when a button is clicked
      e.preventDefault();
      
    var max_iterations = $('#inputBatchSize').val();
    var limit = $('#inputTotalLimit').val();
    var esUrl = $('#inputElasticsearchUrl').val();
    var esIndex = $('#inputElasticsearchIndex').val();
    var esType = $('#inputElasticsearchType').val();
    
      tableau.connectionData = JSON.stringify({
        elasticsearchUrl: esUrl,
        elasticsearchIndex: esIndex,
        elasticsearchType: esType,
        batchSize:  max_iterations,
        limit: limit
      });
      
      tableau.connectionName = "Elasticsearch " + esUrl + '/' + esIndex + '/' + esType;
      
      // Retrieve the Elasticsearch mapping before we call tableau submit
      // There is a bug when getColumnHeaders is invoked, and you call 'headersCallback'
      // asynchronously
      getElasticsearchTypeMapping(esUrl, esIndex, esType);
    });
  });

})();
</script>
</head>
<body>



  <div class="container-fluid">
    <div class="row">
      <div class="col-md-10 col-md-offset-1">

        <h2>Elasticsearch Tableau Web Data Connector</h2>

        <img src="../resources/elasticsearch.png" class="img-responsive" alt="Responsive image">

        <form id="inputForm">
          <div class="form-group">
            <label for="inputElasticsearchUrl">Elasticsearch URL</label>
            <input class="form-control" id="inputElasticsearchUrl" placeholder="Elasticsearch URL" value="http://usadcpdm63.tnd.us.cbre.net:9200">
          </div>
          <div class="form-group">
            <label for="inputElasticsearchIndex">Index Name</label>
            <input class="form-control" id="inputElasticsearchIndex" placeholder="Name of index like 'index1'" value="rpdw">
          </div>
          <div class="form-group">
            <label for="inputElasticsearchType">Type</label>
            <input class="form-control" id="inputElasticsearchType" placeholder="Name of type like 'user'" value="property">
          </div>
          <div>
          </div>
          <div class="form-group">
            <label for="inputBatchSize">Batch size of per request to Elasticsearch</label>
            <input type="number" class="form-control" id="inputBatchSize" value="15" placeholder="Batch size per request">
          </div>
          <div class="form-group">
            <label for="inputTotalLimit">Total limit on number of rows to sync</label>
            <input type="number" class="form-control" id="inputTotalLimit" value="1000" placeholder="Total limit">
          </div>
          <button id="submitButton" type="submit" class="btn btn-default">Submit</button>
        </form>
      </div>

    </div>
    <div class="row">
      <div class="col-md-10 col-md-offset-1">
        <div class="alert alert-success">
        <p>To add more rows of data you will need to:</p>
        <ul>
          <li>Select Tableau's data menu
            <li>Select your data source name
              <li>Then select incremental refresh from extract menu.
        </ul>
        </div>
      </div>
    </div>
  </div>

</body>

</html>